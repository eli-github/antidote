#!/bin/sh
# or, we could use Dash explicitly: #!/usr/bin/env dash

# If /bin/sh is Zsh (which it never is), be sure to set proper POSIX compat.
if [ -n "$ZSH_VERSION" ]; then
  setopt POSIX_ARGZERO
fi

ANTIBODY_VERSION="1.9.7"
THIS_SCRIPT="$(realpath "$0")"
NL='
'  # $'\n' didn't work in dash, so use a hard newline
AWK="awk"
if gawk --version >/dev/null 2>/dev/null; then
  AWK="gawk"
elif mawk --version >/dev/null 2>/dev/null; then
  AWK="mawk"
fi

#region Helpers
# POSIX test for function existance.
is_function() {
  [ "$#" -eq 1 ] || return 1
  type "$1" 2>/dev/null | sed "s/$1//" | grep -qwi function
}

contains() {
  local key item
  if [ "$#" -eq 0 ]; then
    printerr "contains: Key not specified"
    return 1
  fi
  key="$1"
  shift
  for item in "$@"; do
    [ "$key" = "$item" ] && return 0
  done
  return 1
}

print() {
  printf '%s\n' "$@"
}

printerr() {
  printf >&2 '%s\n' "$@"
}

usage() {
  local awk_gethelp
  # shellcheck disable=SC2016
  awk_gethelp='
    BEGIN { len=0 }
    /^##\?/ {
      sub(/^##\? ?/, "", $0)
      arr[len++] = $0
      next
    }
    $0~"^"fn"\\(" {
      for (i=0; i<len; i++) {
        print arr[i]
      }
      {exit}
    }
    { split("", arr); len=0 }
  '
  $AWK -v "fn=${1:-antibody_main}" "$awk_gethelp" "$THIS_SCRIPT"
}

to_url() {
  local url
  case "$1" in
    (*://*)     url="$1" ;;
    (git@*:*/*) url="$1" ;;
    (*)         url="https://github.com/$1" ;;
  esac
  print "$url"
}

to_bundle_path() {
  local result
  case "$1" in
    (/*)
      print "$1"
      ;;
    (*)
      result="$(
        to_url "$1" |
        sed -e "s/\@/-AT-/g" \
            -e "s/\:/-COLON-/g" \
            -e "s/\\//-SLASH-/g" \
            -e "s/.git$//"
      )"
      print "$(antibody_cmd_home)/$result"
      ;;
  esac
}

get_bundle_type() {
  local bundle result
  bundle="$1"
  if [ -z "$bundle" ]; then
    result="empty"
  elif [ -f "$bundle" ]; then
    result="file"
  elif [ -d "$bundle" ]; then
    result="dir"
  elif [ -e "$bundle" ]; then
    result="path"
  fi

  if [ -n "$result" ]; then
    print "$result"
    return 0
  fi

  # Determine the bundle type.
  case "$bundle" in
    (*://*) result=url    ;;
    (*@*:*) result=sshurl ;;
    (*/*/*) result="?"    ;;
    (*/)    result="?"    ;;
    (*/*)   result=repo   ;;
    (*)     result="?"    ;;
  esac
  print "$result"
}

sanity_check_path() {
  # Do a simple sanity check to make sure we're in the user's $HOME.
  case "$1" in ("$HOME"/*) return 0;; esac
  return 1
}

update_repo() {
  local oldsha newsha
  oldsha="$(git -C "$1" rev-parse --short HEAD)"
  git -C "$1" pull --quiet --ff --rebase --autostash
  newsha="$(git -C "$1" rev-parse --short HEAD)"
  if [ "$oldsha" != "$newsha" ]; then
    print "antibody: updated: $2 $oldsha -> $newsha"
  fi
}

fake_clone_repos() {
  # TODO! Gotta actually do something here, but this is how we fake making the tests go.
  local bundle_path omzdir
  omzdir="https-COLON--SLASH--SLASH-github.com-SLASH-ohmyzsh-SLASH-ohmyzsh"
  bundle_path="$HOME/.cache/antibody/$omzdir"
  if [ ! -d "$bundle_path" ]; then
    git clone --quiet --depth 1 --recurse-submodules --shallow-submodules "https://github.com/ohmyzsh/ohmyzsh" "$bundle_path"
  fi
  print \
    "source \$HOME/.cache/antibody/$omzdir/oh-my-zsh.sh" \
    "fpath+=( \$HOME/.cache/antibody/$omzdir )"
}

clone_repos() {
  # local awk_clone
  # # shellcheck disable=SC2016
  # awk_clone='
  #    BEGIN { RS="[\r\n]" }
  #     /\t/ { gsub(/\t/, " ", $0) }
  #          { gsub(/ +#.*$/, "", $0) }
  #          { gsub(/^ +| +$/, "", $0) }
  #     /^#/ { next }
  #     /^$/ { next }
  #          { print }'

  printf 'cloning: %s\n' "$@"
}
#endregion

#region Subcommands
antibody_opt_version() {
  print "antibody version $ANTIBODY_VERSION"
}

##? usage: antibody help [<command>...]
##?
##? Show help.
##?
##? Args:
##?  [<command>]  Show help on command.
##?
antibody_cmd_help() {
  local funcname
  if [ -z "$1" ]; then
    usage
  elif contains "$1" help bundle update home purge list path init; then
    usage "antibody_cmd_$1"
  else
    printerr "antibody: error: expected command but got '$1'."
    return 1
  fi
}

##? usage: antibody bundle [<bundles>...]
##?
##? downloads a bundle and prints its source line
##?
##? Args:
##?  [<bundles>]  bundle list
##?
antibody_cmd_bundle() {
  local awk_scrub args

  # Save args as a string before setting IFS because we're gonna
  # need to reparse it with only newline word splitting.
  args="$*"

  # handle whatever line ending
  # replace tabs with a space
  # strip trailing comments
  # trim whitespace from both sides
  # skip commented lines and print the rest
  # shellcheck disable=SC2016
  awk_scrub='
     BEGIN { RS="[\r\n]" }
      /\t/ { gsub(/\t/, " ", $0) }
           { gsub(/ +#.*$/, "", $0) }
           { gsub(/^ +| +$/, "", $0) }
      /^#/ { next }
      /^$/ { next }
           { print }'

  # scrub bundles and re-split on newlines
  set -f   # disable globbing of when splitting bundles
  IFS=$NL  # configure the split newline delimeters
  if [ ! -t 0 ]; then
    # shellcheck disable=SC2046
    set -- $($AWK "$awk_scrub" -)
  elif [ "$#" -ne 0 ]; then
    # shellcheck disable=SC2046
    set -- $(echo "$args" | $AWK "$awk_scrub")
  fi
  set +f
  unset IFS

  # Clone anything that's missing
  fake_clone_repos "$@"
}

##? usage: antibody update
##?
##? updates all previously bundled bundles
##?
antibody_cmd_update() {
  local antibody_home bundle_path url
  antibody_home="$(antibody_cmd_home)"
  print "Updating all bundles in $antibody_home..."

  if [ ! -d "$antibody_home" ]; then
    printerr "antibody: error: failed to update: open ${antibody_home}: no such file or directory"
    return 1
  fi

  for bundle_path in "$antibody_home"/*; do
    url="$(git -C "$bundle_path" config remote.origin.url)"
    print "antibody: updating: $url"
    update_repo "$bundle_path" "$url" &
  done
  wait
}

##? usage: antibody home
##?
##? prints where antibody is cloning the bundles
##?
antibody_cmd_home() {
  if [ -n "$ANTIBODY_HOME" ]; then
    print "$ANTIBODY_HOME"
    return
  fi

  local cachedir ostype
  ostype="$(uname -s | tr '[:upper:]' '[:lower:]')"
  if test -n "$T_ANTIBODY_OSTYPE"; then
    ostype="$T_ANTIBODY_OSTYPE"
  fi

  case "$ostype" in
    (darwin*) cachedir="$HOME/Library/Caches" ;;
    (cygwin*) cachedir=$(cygpath "${LOCALAPPDATA:-$LocalAppData}") ;;
    (msys*)   cachedir="${LOCALAPPDATA:-$LocalAppData}" ;;
    (*)       cachedir="${XDG_CACHE_HOME:-$HOME/.cache}" ;;
  esac

  case "$cachedir" in
    (*/*)  print "$cachedir/antibody" ;;
    (*\\*) print "$cachedir\\antibody" ;;
    (*)    print "$(realpath "$cachedir")/antibody" ;;
  esac
}

##? usage: antibody purge <bundle>
##?
##? purges a bundle from your computer
##?
##? Args:
##?   <bundle>  bundle to be purged
##?
antibody_cmd_purge() {
  if [ "$#" -eq 0 ]; then
    printerr "antibody: error: required argument 'bundle' not provided, try --help"
    return 1
  fi

  local bundle_path
  bundle_path="$(to_bundle_path "$1")"
  if ! sanity_check_path "$bundle_path"; then
    printerr "antibody: error: bundle path failed sanity check: $bundle_path"
    return 1
  elif [ -r "$bundle_path" ]; then
    print "Removing $1..."
    if [ "${T_ANTIBODY_PURGE:-1}" -ne 0 ]; then
      command rm -rf -- "$bundle_path"
    else
      echo rm -rf -- "$bundle_path"
    fi
    print "removed!"
  else
    printerr "antibody: error: $1 does not exist in expected location: $bundle_path"
    return 1
  fi
}

##? usage: antibody list
##?
##? lists all currently installed bundles
##?
antibody_cmd_list() {
  local antibody_home
  antibody_home=$(antibody_cmd_home)
  if [ ! -d "$antibody_home" ]; then
    printerr "antibody: error: failed to list bundles: open ${antibody_home}: no such file or directory"
    return 1
  fi

  local bundle_path url
  for bundle_path in "$antibody_home"/*; do
    url="$(git -C "$bundle_path" config remote.origin.url)"
    printf '%-64s %s\n' "$url" "$bundle_path"
  done
}

##? usage: antibody path <bundle>
##?
##? prints the path of a currently cloned bundle
##?
##? Args:
##?   <bundle>  bundle in which to find and print cloned path
##?
antibody_cmd_path() {
  if [ "$#" -eq 0 ]; then
    printerr "antibody: error: required argument 'bundle' not provided, try --help"
    return 1
  fi

  local bundle bundle_path
  bundle="$1"
  bundle_path="$(to_bundle_path "$bundle")"

  if [ ! -d "$bundle_path" ]; then
    printerr "antibody: error: ${bundle} does not exist in cloned paths"
    return 1
  fi

  print "$bundle_path"
}

##? usage: antibody init
##?
##? initializes the shell so Antibody can work as expected
##?
antibody_cmd_init() {
  cat << 'HEREDOC' | sed -e "s|\$THIS_SCRIPT|$THIS_SCRIPT|g"
#!/usr/bin/env zsh
antibody() {
  case "$1" in
  bundle)
    source <( $THIS_SCRIPT $@ ) || $THIS_SCRIPT $@
    ;;
  *)
    $THIS_SCRIPT $@
    ;;
  esac
}

_antibody() {
  IFS=' ' read -A reply <<< "help bundle update home purge list path init"
}
compctl -K _antibody antibody
HEREDOC
}
#endregion

##? usage: antibody [<flags>] <command> [<args> ...]
##?
##? A pure Zsh implementation of the legacy antibody plugin manager
##? Packaged with the antidote plugin manager
##?
##? Flags:
##?   -h, --help           Show context-sensitive help.
##?   -v, --version        Show application version.
##?
##? Commands:
##?   help [<command>...]
##?     Show help.
##?
##?   bundle [<bundles>...]
##?     downloads a bundle and prints its source line
##?
##?   update
##?     updates all previously bundled bundles
##?
##?   home
##?     prints where antibody is cloning the bundles
##?
##?   purge <bundle>
##?     purges a bundle from your computer
##?
##?   list
##?     lists all currently installed bundles
##?
##?   path <bundle>
##?     prints the path of a currently cloned bundle
##?
##?   init
##?     initializes the shell so Antibody can work as expected
##?
antibody_main() {
  if [ "$#" -eq 0 ]; then
    antibody_cmd_help
    return 0
  fi

  local o_bad o_help o_ver subcmd
  while [ $# -gt 0 ]; do
    case $1 in
      --)           shift;      break ;;
      -h|--help)    o_help="$1"       ;;
      -v|--version) o_ver="$1"        ;;
      -*)           o_bad="$1"        ;;
      *)                        break ;;
    esac
    shift
  done

  if [ -n "$o_bad" ]; then
     printerr "antibody: Unknown flag '$o_bad'. Usage 'antibody -h'."
     return 1
  elif [ -n "$o_help" ]; then
    antibody_cmd_help
    return 0
  elif [ -n "$o_ver" ]; then
    antibody_opt_version
    return 0
  fi

  # Call the subcommand if it exists.
  if is_function "antibody_cmd_${1}"; then
    subcmd="$1"
    shift
    "antibody_cmd_${subcmd}" "$@"
    return
  else
    printerr "antibody: error: expected command but got \"$1\", try --help"
    return 1
  fi
}
antibody_main "$@"

# vim: set sw=2 sts=2 ts=8 et:
