#!/usr/bin/env zsh

# Script path vars.
SCRIPT_PATH="${${(%):-%N}:a}"
SCRIPT_DIR="${SCRIPT_PATH:h}"
SCRIPT_NAME="${SCRIPT_PATH:t}"

# Make sure we're using a supported version of Zsh.
if [[ -n "$ZSH_VERSION" ]]; then
  builtin autoload -Uz is-at-least
  if ! is-at-least 5.4.2; then
    print -ru2 -- "$SCRIPT_NAME: Unsupported Zsh version '$ZSH_VERSION'. Expecting Zsh >=5.4.2."
    exit 1
  fi
  setopt NULL_GLOB NO_BANG_HIST EXTENDED_GLOB NO_MONITOR PIPEFAIL
else
  shellname=$(ps -p $$ -oargs= | awk 'NR=1{print $1}')
  print -ru2 -- "$SCRIPT_NAME: Expecting zsh or bash. Found '$shellname'."
  exit 1
fi

# Set antidote variables.
ANTIDOTE_VERSION=2.0.0
: "${ANTIDOTE_GIT_SITE:=https://github.com}"
: "${ANTIDOTE_OSTYPE:=${OSTYPE:-$(uname -s | tr '[:upper:]' '[:lower:]')}}"
: "${ANTIDOTE_DEBUG:=false}"
: "${ANTIDOTE_COMPATIBILITY_MODE:=}"

# -D : Delete flags from the param array once they are detected
# -M : Map a flag to alternative names (useful for defining -s(hort) and --long options)
# -F : Fail if a flad is provided that was not defined in the zparseops spec (added in 5.8)
ANTIDOTE_ZPARSEOPTS=(-D -M)
is-at-least 5.8 && ANTIDOTE_ZPARSEOPTS+=(-F)

# Set variables.
NL=$'\n'
TAB=$'\t'
SEP=$'\x1F'

# Util functions.
die()  { ec=$1; shift; warn "$@"; exit $ec; }
warn() { printf '%s: %s\n' "$SCRIPT_NAME" "$*" >&2; }
say()  { printf '%s\n' "$@"; }
#is_func() { typeset -f "${1}" >/dev/null 2>&1 ; }
#is_cmd()  { command -v "${1}" >/dev/null 2>&1 ; }

# Get the default cache directory by OS.
cache_dir() {
  local result
  if [[ "${ANTIDOTE_OSTYPE}" == darwin* ]]; then
    result="$HOME/Library/Caches"
  elif [[ "${ANTIDOTE_OSTYPE}" == cygwin* || "${ANTIDOTE_OSTYPE}" == msys* ]]; then
    result="${LOCALAPPDATA:-$LocalAppData}"
    if (( $+commands[cygpath] )); then
      result="$(cygpath "$result")"
    fi
  fi
  [[ -n "$result" ]] || result="${XDG_CACHE_HOME:-$HOME/.cache}"

  if [[ -n "$1" ]]; then
    if [[ $result == *\\* ]] && [[ $result != */* ]]; then
      result+="\\$1"
    else
      result+="/$1"
    fi
  fi
  say "$result"
}

# Collect <redirected or piped| input.
collect_args() {
  local arg line
  local -a results=()

  for arg in "$@"; do
    arg="${arg//\\n/$NL}"
    while IFS= read -r line || [[ -n "$line" ]]; do
      results+=("$line")
    done < <(printf '%s' "$arg")
  done
  if [[ ! -t 0 ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      results+=("$line")
    done
  fi
  typeset -ga reply=("${results[@]}")
  [[ "$ANTIDOTE_DEBUG" != true ]] || say "${reply[@]}"
}

# Safe rm wrapper
del() {
  # Call me paranoid, but I want to be really certain antidote will never rm something
  # it shouldn't. This function wraps rm to double check that any paths being removed
  # are valid. If it's not in your $HOME or $TMPDIR, we need to block it.
  local p tmpdir
  local -a rmflags

  while (( $# )); do
    case "$1" in
      --)  shift; break     ;;
      -*)  rmflags+=("$1")  ;;
      *)   break            ;;
    esac
    shift
  done
  (( $# > 0 )) || return 1

  tmpdir="$(temp_dir)"
  for p in "$@"; do
    p="${p:a}"
    if [[ "$p" != "$HOME"/* ]] && [[ "$p" != "$tmpdir"/* ]]; then
      warn "Blocked attempt to rm path: '$p'."
      return 1
    fi
  done

  rm "${rmflags[@]}" -- "$@"
}

# git command
gitcmd() {
  local result ret
  result="$("${ANTIDOTE_GITCMD:-git}" "$@" 2>&1)"
  ret=$?
  if (( ret > 0 )); then
    if [[ -n "$result" ]]; then
      printf >&2 "antidote: unexpected git error on command 'git %s'.\n" "$*"
      printf >&2 "antidote: error details:\n"
      printf >&2 "%s\n" "$result"
      return $ret
    fi
  fi
  printf '%s\n' "$result"
}

# Use shell's lexer for word splitting rules
wordsplit() {
  local str="$*"
  str="${str//\$/\\\$}"
  eval "set -- $str"
  typeset -ga reply=("$@")
  [[ "$ANTIDOTE_DEBUG" != true ]] || say "${reply[@]}"
}

# Parse bundles into an associative array.
parse_bundles() {
  # Creates a parsed_bundle associative array with following contents:
  #   parsed_bundle[name]: Name of the bundle
  #   parsed_bundle[lineno]: The line number from .zsh_plugins.txt
  #   parsed_bundle[$annotation]: key:value pairs for all provided annotations

  collect_args "$@" >/dev/null
  local -a bundles=( "${reply[@]}" )
  unset reply
  local -a kvpairs=() results=()
  local pair key value bundle lineno=0
  local -A parsed_bundle=()

  for bundle in "${bundles[@]}"; do
    (( lineno += 1 ))

    bundle="${bundle%%\#*}"                        # Remove anything after the first '#'
    bundle="${bundle#"${bundle%%[![:space:]]*}"}"  # Trim leading spaces
    bundle="${bundle%"${bundle##*[![:space:]]}"}"  # Trim trailing spaces

    # Skip empty bundles
    [[ -n "$bundle" ]] || continue

    # 1st field gets a 'name:' prefix so we can treat everything as key:val pairs
    bundle="name:${bundle}"

    # Split line into key-value pairs with quoting
    parsed_bundle=()
    parsed_bundle[lineno]="$lineno"

    wordsplit "${bundle}" >/dev/null
    kvpairs=("${reply[@]}")
    unset reply

    for pair in "${kvpairs[@]}"; do
      if [[ "$pair" != *:* ]]; then
        die 1 "missing ':' in bundle annotation '$pair' on line $lineno"
      fi

      key="${pair%%:*}"  # Extract key (before first ':')
      if [[ "$pair" == *:* ]]; then
        value="${pair#*:}"  # Extract value (after first ':')
      else
        value=""
      fi
      parsed_bundle[$key]="$value"
    done

    # Enhance bundle


    results+=( "$(declare -p parsed_bundle)" )
  done

  # Set reply array
  typeset -ga reply=("${results[@]}")
  [[ "$ANTIDOTE_DEBUG" != true ]] || say "${reply[@]}"
}

# Expand bundles into an associative array.
expand_bundles() {

}

# Print the OS specific temp dir.
temp_dir() {
  local result tmpd

  # Set the appropriate temp directory (cargo cult code from p10k)
  if [[ -n "$TMPDIR" && (( -d "$TMPDIR" && -w "$TMPDIR" ) || ! ( -d /tmp && -w /tmp )) ]]; then
    tmpd="${TMPDIR%/}"
  else
    tmpd="/tmp"
  fi
  result="$tmpd"
  say "$result"
}

# Print help.
antidote_help() {
  local -a usage=(
    "antidote - the cure to slow zsh plugin management"
    ""
    "Usage: antidote [<flags>] <command> [<args> ...]"
    ""
    "Flags:"
    "  -h, --help           Show context-sensitive help"
    "  -v, --version        Show application version"
    ""
    "Commands:"
    "  help      Show documentation"
    "  load      Statically source all bundles from the plugins file"
    "  bundle    Clone bundle(s) and generate the static load script"
    "  install   Clone a new bundle and add it to your plugins file"
    "  update    Update antidote and its cloned bundles"
    "  purge     Remove a cloned bundle"
    "  home      Print where antidote is cloning bundles"
    "  list      List cloned bundles"
    "  path      Print the path of a cloned bundle"
    "  init      Initialize the shell for dynamic bundles"
  )

  local -a bundle_usage=(
    "Usage: antidote bundle [<bundles>...]"
    ""
    "Clones a bundle and prints its source line"
    ""
    "Flags:"
    "  -h, --help   Show context-sensitive help."
    ""
    "Args:"
    "  [<bundles>]  Bundle list"
  )

  local -a home_usage=(
    "usage: antidote home"
    ""
    "Prints where antidote is cloning bundles"
    ""
    "Flags:"
    "  -h, --help   Show context-sensitive help."
  )

  local -a init_usage=(
    "usage: antidote init"
    ""
    "Initializes the shell so antidote can load bundles dynmically"
    ""
    "Flags:"
    "  -h, --help   Show context-sensitive help."
  )

  local -a path_usage=(
    "usage: antidote path <bundle>"
    ""
    "Prints the path of a currently cloned bundle"
    ""
    "Flags:"
    "  -h, --help   Show context-sensitive help."
    ""
    "Args:"
    "  <bundle>     The Bundle path to print"
  )

  case "$1" in
    bundle) say "${bundle_usage[@]}" ;;
    home)   say "${home_usage[@]}"   ;;
    init)   say "${init_usage[@]}"   ;;
    path)   say "${path_usage[@]}"   ;;
    *)      say "${usage[@]}"        ;;
  esac
}

# Print home directory for antidote.
antidote_home() {
  local result

  case "$1" in
    -h|--help)
      antidote_help home
      return 0
      ;;
  esac

  if [[ -n "$ANTIDOTE_HOME" ]]; then
    result="$ANTIDOTE_HOME"
  else
    result="$(cache_dir antidote)"
  fi
  printf '%s\n' "$result"
}

# Initialize the shell for dynamic bundles.
antidote_init() {
  local -a script=(
    "#!/usr/bin/env zsh"
    "antidote() {"
    "  local antidote_cmd=\"$SCRIPT_PATH\""
    "  case \"\$1\" in"
    "    bundle)"
    "      source <( \$antidote_cmd \$@ ) || \$antidote_cmd \$@"
    "      ;;"
    "    *)"
    "      \$antidote_cmd \$@"
    "      ;;"
    "  esac"
    "}"
    ""
    "_antidote() {"
    "  IFS=' ' read -A reply <<< \"help bundle update home purge list init\""
    "}"
    "compctl -K _antidote antidote"
  )
  say "$script[@]"
}

# Get the antidote version.
antidote_version() {
  local ver gitsha
  ver="$ANTIDOTE_VERSION"
  gitsha="$(gitcmd -C "$SCRIPT_DIR" rev-parse --short HEAD 2>/dev/null)"
  [[ -z "$gitsha" ]] || ver="$ver ($gitsha)"
  say "antidote version $ver"
}

antidote2() {
  local o_help o_version o_debug
  zparseopts ${ANTIDOTE_ZPARSEOPTS} -- \
    d=o_debug   -debug=d   \
    h=o_help    -help=h    \
    v=o_version -version=v ||
    return 1

  if (( ${#o_debug} )); then
    ANTIDOTE_DEBUG=true
    setopt WARN_CREATE_GLOBAL WARN_NESTED_VAR
  fi

  if (( ${#o_version} )); then
    antidote_version
    return 0

  elif (( ${#o_help} )); then
    antidote_help "$@"
    return 0

  elif [[ ${#} -eq 0 ]]; then
    antidote_help
    return 2
  fi

  local cmd=${1}; shift
  if [[ "$ANTIDOTE_DEBUG" == true ]] && [[ "$cmd" == run ]]; then
    cmd="$1"
    shift
    "${cmd}" "$@"
    return $?
  elif (( $+functions[antidote_${cmd}] )); then
    antidote_${cmd} "$@"
    return $?
  else
    die 2 "command not found '$cmd'."
  fi
}
antidote2 "$@"
