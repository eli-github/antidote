#!/usr/bin/env zsh

# Script path vars.
SCRIPT_PATH="${${(%):-%N}:a}"
SCRIPT_DIR="${SCRIPT_PATH:h}"
SCRIPT_NAME="${SCRIPT_PATH:t}"

# Make sure we're using a supported version of Zsh.
if [[ -n "$ZSH_VERSION" ]]; then
  builtin autoload -Uz is-at-least
  if ! is-at-least 5.4.2; then
    print -ru2 -- "$SCRIPT_NAME: Unsupported Zsh version '$ZSH_VERSION'. Expecting Zsh >=5.4.2."
    exit 1
  fi
  setopt NULL_GLOB NO_BANG_HIST EXTENDED_GLOB NO_MONITOR PIPEFAIL
else
  shellname=$(ps -p $$ -oargs= | awk 'NR=1{print $1}')
  print -ru2 -- "$SCRIPT_NAME: Expecting zsh or bash. Found '$shellname'."
  exit 1
fi

# Set antidote variables.
ANTIDOTE_VERSION=2.0.0
: "${ANTIDOTE_USE:=}"
: "${ANTIDOTE_GIT_SITE:=https://github.com}"
: "${ANTIDOTE_OSTYPE:=${OSTYPE:-$(uname -s | tr '[:upper:]' '[:lower:]')}}"
: "${ANTIDOTE_DEBUG:=false}"
: "${ANTIDOTE_COMPATIBILITY_MODE:=}"

# -D : Delete flags from the param array once they are detected
# -M : Map a flag to alternative names (useful for defining -s(hort) and --long options)
# -F : Fail if a flad is provided that was not defined in the zparseops spec (added in 5.8)
ANTIDOTE_ZPARSEOPTS=(-D -M)
is-at-least 5.8 && ANTIDOTE_ZPARSEOPTS+=(-F)

# Set variables.
NL=$'\n'
TAB=$'\t'
SEP=$'\x1F'

# Util functions.
die()  { local ec=$1; shift; warn "$@"; exit $ec; }
warn() { printf '%s: %s\n' "$SCRIPT_NAME" "$*" >&2; }
say()  { printf '%s\n' "$@"; }
#is_func() { typeset -f "${1}" >/dev/null 2>&1 ; }
#is_cmd()  { command -v "${1}" >/dev/null 2>&1 ; }
is_true() { [[ -n "$1" && "${1:l}" == (1|y(es|)|t(rue|)|o(n|)) ]]; }

# Trim string.
trim() {
  local s="$1"
  # Trim leading and trailing spaces.
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

# Get the default cache directory by OS.
cache_dir() {
  local result
  if [[ "${ANTIDOTE_OSTYPE}" == darwin* ]]; then
    result="$HOME/Library/Caches"
  elif [[ "${ANTIDOTE_OSTYPE}" == cygwin* || "${ANTIDOTE_OSTYPE}" == msys* ]]; then
    result="${LOCALAPPDATA:-$LocalAppData}"
    if (( $+commands[cygpath] )); then
      result="$(cygpath "$result")"
    fi
  fi
  [[ -n "$result" ]] || result="${XDG_CACHE_HOME:-$HOME/.cache}"

  if [[ -n "$1" ]]; then
    if [[ $result == *\\* ]] && [[ $result != */* ]]; then
      result+="\\$1"
    else
      result+="/$1"
    fi
  fi
  say "$result"
}

# Collect <redirected or piped| input.
collect_args() {
  local arg line
  local -a results=()

  for arg in "$@"; do
    arg="${arg//\\n/$NL}"
    while IFS= read -r line || [[ -n "$line" ]]; do
      results+=("$line")
    done < <(printf '%s' "$arg")
  done
  if [[ ! -t 0 ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      results+=("$line")
    done
  fi
  typeset -ga reply=("${results[@]}")
  [[ "$ANTIDOTE_DEBUG" != true ]] || say "${reply[@]}"
}

# Safe rm wrapper
del() {
  # Call me paranoid, but I want to be really certain antidote will never rm something
  # it shouldn't. This function wraps rm to double check that any paths being removed
  # are valid. If it's not in your $HOME or $TMPDIR, we need to block it.
  local p tmpdir
  local -a rmflags

  while (( $# )); do
    case "$1" in
      --)  shift; break     ;;
      -*)  rmflags+=("$1")  ;;
      *)   break            ;;
    esac
    shift
  done
  (( $# > 0 )) || return 1

  tmpdir="$(temp_dir)"
  for p in "$@"; do
    p="${p:a}"
    if [[ "$p" != "$HOME"/* ]] && [[ "$p" != "$tmpdir"/* ]]; then
      warn "Blocked attempt to rm path: '$p'."
      return 1
    fi
  done

  rm "${rmflags[@]}" -- "$@"
}

# git command
gitcmd() {
  local result ret
  result="$("${ANTIDOTE_GITCMD:-git}" "$@" 2>&1)"
  ret=$?
  if (( ret > 0 )); then
    if [[ -n "$result" ]]; then
      printf >&2 "antidote: unexpected git error on command 'git %s'.\n" "$*"
      printf >&2 "antidote: error details:\n"
      printf >&2 "%s\n" "$result"
      return $ret
    fi
  fi
  printf '%s\n' "$result"
}

# Use shell's lexer for word splitting rules
wordsplit() {
  local str="$*"
  str="${str//\$/\\\$}"
  eval "set -- $str"
  typeset -ga reply=("$@")
  [[ "$ANTIDOTE_DEBUG" != true ]] || say "${reply[@]}"
}

# Parse bundles into an associative array.
parse_bundles() {
  # Creates a bundle associative array with following contents:
  #   bundle[ref]: Reference name of the bundle
  #   bundle[lineno]: The line number from .zsh_plugins.txt
  #   bundle[$annotation]: key:value pairs for all provided annotations

  collect_args "$@" >/dev/null
  local -a bundles=( "${reply[@]}" )
  unset reply
  local -a kvpairs=() results=()
  local pair key value line lineno=0 itemno=0
  local -A bundle=()

  for line in "${bundles[@]}"; do
    (( lineno++ ))

    # Remove anything after the first '#' and trim
    line="${line%%\#*}"
    line="$(trim "$line")"

    # Skip empty lines
    [[ -n "$line" ]] || continue

    # Split line into key-value pairs with quoting
    wordsplit "${line}" >/dev/null
    kvpairs=("${reply[@]}")
    unset reply

    bundle=()
    bundle[lineno]="$lineno"
    itemno=0
    for pair in "${kvpairs[@]}"; do
      (( itemno++ ))
      # 1st field gets a '_:' prefix so we can treat everything as key:val pairs
      if [[ $itemno -eq 1 ]]; then
        if [[ "$pair" != *:* || "$pair" == (git|http)* ]]; then
          pair="_:${pair}"
        fi
      fi

      if [[ "$pair" != *:* ]]; then
        die 1 "missing ':' in bundle annotation '$pair' on line $lineno"
      fi

      key="${pair%%:*}"  # Extract key (before first ':')
      if [[ "$pair" == *:* ]]; then
        value="${pair#*:}"  # Extract value (after first ':')
      else
        value=""
      fi
      bundle[$key]="$value"
    done

    # Enhance bundle


    results+=( "$(declare -p bundle)" )
  done

  # Set reply array
  typeset -ga reply=("${results[@]}")
  [[ "$ANTIDOTE_DEBUG" != true ]] || say "${reply[@]}"
}

# Print the OS specific temp dir.
temp_dir() {
  local result tmpd

  # Set the appropriate temp directory (cargo cult code from p10k)
  if [[ -n "$TMPDIR" && (( -d "$TMPDIR" && -w "$TMPDIR" ) || ! ( -d /tmp && -w /tmp )) ]]; then
    tmpd="${TMPDIR%/}"
  else
    tmpd="/tmp"
  fi
  result="$tmpd"
  say "$result"
}

# Get the URL for a bundle.
tourl() {
  local bundle=$1
  if [[ $bundle != *://* && $bundle != git@*:*/* ]]; then
    say ${ANTIDOTE_GIT_SITE:-https://github.com}/$bundle
  else
    say $bundle
  fi
}

# Convert git URLs to user/repo format
url_to_short_repo() {
  local str

  str="${1%/}"       # strip trailing /
  str="${str%.git}"  # strip trailing .git

  # strip the domain
  if [[ "$str" == *://*/*/* ]]; then
    str="${str#*://*/}"
  elif [[ "$str" == git@*:*/* ]]; then
    str="${str#git@*:}"
  else
    return 1
  fi

  # make sure whatever is left is repo_user/repo_name
  [[ "$str" == */* ]] && [[ "$str" != */*/* ]] || return 1
  say "$str"
}

# Get the base directory of a bundle.
bundle_dir() {
  if (( $# == 0 )); then
    die 1 "required argument 'bundle' not provided"
  fi

  local bundle=$1
  if [[ "$bundle" == /* ]]; then
    say "$bundle"
  elif [[ "$bundle" == (git@|http://|https://)* ]]; then
    if is_true "$ANTIDOTE_COMPATIBILITY_MODE"; then
      local url=$(tourl $bundle)
      url=${url%.git}
      url=${url:gs/\@/-AT-}
      url=${url:gs/\:/-COLON-}
      url=${url:gs/\//-SLASH-}
      say $(antidote_home)/$url
    else
      # user/repo format
      # ex: $ANTIDOTE_HOME/zsh-users/zsh-autosuggestions
      bundle=${bundle%.git}
      bundle=${bundle:gs/\:/\/}
      local parts=( ${(ps./.)bundle} )
      if [[ $#parts -gt 1 ]]; then
        say $(antidote_home)/${parts[-2]}/${parts[-1]}
      else
        say $(antidote_home)/$bundle
      fi
    fi
  elif [[ "$bundle" == */* && "$bundle" != */*/* ]]; then
    say "$(antidote_home)/$bundle"
  else
    die 1 "unexpected bundle argument '$bundle'."
  fi
}

# Print help.
print_help() {
  0="${(%):-%x}"
  local cmd funcname line print_on=0
  local -a lines

  # Read whole file into an array (pure zsh, no external commands).
  lines=("${(@f)$(<"${0:a}")}")
  cmd="$1"
  if (( $+functions[antidote_${cmd}] )); then
    funcname="antidote_${cmd}"
  else
    funcname="antidote2"
  fi

  for line in $lines; do
    # Trim leading and trailing spaces.
    line="$(trim "$line")"
    if [[ $line == "${funcname}() {" ]]; then
      print_on=1
    elif [[ $line == "##?"* ]]; then
      line="${line#\#\#\? }"
      line="${line#\#\#\?}"
      if [[ $print_on -ne 0 ]]; then
        say $line
      fi
    elif [[ $line == "}" && $print_on -ne 0 ]]; then
      return
    fi
  done
}

# git helpers
git_basedir()  { gitcmd -C "$1" rev-parse --show-toplevel; }
git_url()      { gitcmd -C "$1" config remote.origin.url; }
git_branch()   { gitcmd -C "$1" rev-parse --abbrev-ref HEAD; }
git_sha()      { gitcmd -C "$1" rev-parse HEAD; }
git_repodate() { gitcmd -C "$1" log -1 --format=%cd --date=short; }

# Parse bundles into an associative array.
antidote_bundle() {
  ##? Usage: antidote bundle [<bundles>...]
  ##?
  ##? Clones a bundle and prints its source line.
  ##?
  ##? Flags:
  ##?   -h, --help   Show context-sensitive help.
  ##?
  ##? Args:
  ##?   [<bundles>]  Bundle list.
}

# Print help.
antidote_help() {
  print_help "$@"
}

# Print home directory for antidote.
antidote_home() {
  ##? usage: antidote home
  ##?
  ##? Prints where antidote is cloning bundles.
  ##?
  ##? Flags:
  ##?   -h, --help   Show context-sensitive help.
  [[ "$1" == (-h|--help) ]] && { print_help home; return }

  local result

  case "$1" in
    -h|--help)
      antidote_help home
      return 0
      ;;
  esac

  if [[ -n "$ANTIDOTE_HOME" ]]; then
    result="$ANTIDOTE_HOME"
  else
    result="$(cache_dir antidote)"
  fi
  printf '%s\n' "$result"
}

# Initialize the shell for dynamic bundles.
antidote_init() {
  ##? usage: antidote init
  ##?
  ##? Initializes the shell so antidote can load bundles dynmically.
  ##?
  ##? Flags:
  ##?   -h, --help   Show context-sensitive help.
  [[ "$1" == (-h|--help) ]] && { print_help init; return }

  local -a script=(
    "#!/usr/bin/env zsh"
    "antidote() {"
    "  local antidote_cmd=\"$SCRIPT_PATH\""
    "  case \"\$1\" in"
    "    bundle)"
    "      source <( \$antidote_cmd \$@ ) || \$antidote_cmd \$@"
    "      ;;"
    "    *)"
    "      \$antidote_cmd \$@"
    "      ;;"
    "  esac"
    "}"
    ""
    "_antidote() {"
    "  IFS=' ' read -A reply <<< \"help bundle update home purge list init\""
    "}"
    "compctl -K _antidote antidote"
  )
  say "$script[@]"
}

# List cloned bundles.
antidote_list() {
  ##? usage: antidote list [-d|--details] [-bcprsu]
  ##?
  ##? Lists all currently installed bundles
  ##?
  ##? Flags:
  ##?   -h, --help     Show context-sensitive help.
  ##?   -d, --detail   Show full bundle details.
  ##?
  ##? Format flags:
  ##?   -b             Bundle's branch.
  ##?   -c             Bundle's last commit date.
  ##?   -p             Bundle's path.
  ##?   -r             Bundle's short repo name.
  ##?   -s             Bundle's SHA.
  ##?   -u             Bundle's URL.

  local spec bundle_dir bundle_gitdir branch sha repodate url short_repo
  local -a bundles=() o_detail o_help o_format
  zparseopts ${ANTIDOTE_ZPARSEOPTS} -- \
    {d,-detail}=o_detail \
    {h,-help}=o_help \
    b+=o_format \
    p+=o_format \
    u+=o_format \
    r+=o_format \
    s+=o_format \
    c+=o_format ||
    return 1

  if (( ${#o_help} )); then
    antidote_help list
    return 0
  fi

  if is_true "$ANTIDOTE_COMPATIBILITY_MODE"; then
    bundles=($(antidote_home)/*/.git(N/))
  else
    bundles=($(antidote_home)/*/*/.git(N/))
  fi

  # Set the vars.
  for bundle_gitdir in $bundles; do

    # Do this in parallel because we want speed.
    bundle_dir="${bundle_gitdir:a:h}"
    {
      exec {fd_branch}< <(git_branch "$bundle_dir")
      exec {fd_sha}< <(git_sha "$bundle_dir")
      exec {fd_repodate}< <(git_repodate "$bundle_dir")
      exec {fd_url}< <(git_url "$bundle_dir")

      IFS= read -r branch <&$fd_branch
      IFS= read -r sha <&$fd_sha
      IFS= read -r repodate <&$fd_repodate
      IFS= read -r url <&$fd_url
    } always {
      exec {fd_branch}>&- 2>/dev/null
      exec {fd_sha}>&- 2>/dev/null
      exec {fd_repodate}>&- 2>/dev/null
      exec {fd_url}>&- 2>/dev/null
    }
    short_repo="$(url_to_short_repo "$url" 2>/dev/null)"

    # If we want full details, emit verbose block.
    if (( ${#o_format} )); then
      for spec in $o_format; do
        case $spec in
          -b) printf '%s\t' "$branch"     ;;
          -p) printf '%s\t' "$bundle_dir" ;;
          -r) printf '%s\t' "$short_repo" ;;
          -s) printf '%s\t' "$sha"        ;;
          -u) printf '%s\t' "$url"        ;;
          -c) printf '%s\t' "$repodate"   ;;
        esac
      done
      print
    elif (( ${#o_detail} )); then
      say "$short_repo"
      say "====================================================="
      say "Dir:         $bundle_dir"
      say "Branch:      $branch"
      say "SHA:         $sha"
      say "URL:         $url"
      say "Last Commit: $repodate"
      say
    else
      # Default to 'repo dir'
      printf '%-28s  %s\n' $short_repo $bundle_dir
    fi
  done
}

# Print the path of a cloned bundle.
antidote_path() {
  ##? usage: antidote path <bundle>
  ##?
  ##? Prints the path of a currently cloned bundle.
  ##?
  ##? Flags:
  ##?   -h, --help   Show context-sensitive help.
  ##?
  ##? Args:
  ##?   <bundle>     The Bundle path to print.
  [[ "$1" == (-h|--help) ]] && { print_help path; return }

  local bundle_dir bundle="$1"
  (( $# > 0 )) || die 1 "required argument 'bundle' not provided."

  # If a real path was provided, then that's the path.
  if [[ -e "$bundle" && "$bundle" == /* ]]; then
    say "$bundle" && return 0
  fi

  # Figure out the bundle directory.
  bundle_dir="$(bundle_dir "$bundle")"

  # If we haven't errored and we have a valid directory, print it.
  if [[ -d "$bundle_dir" ]]; then
    say "$bundle_dir"
  else
    die 1 "path error: '$bundle' does not exist in cloned paths."
  fi
}

# Get the antidote version.
antidote_version() {
  local ver gitsha
  ver="$ANTIDOTE_VERSION"
  gitsha="$(gitcmd -C "$SCRIPT_DIR" rev-parse --short HEAD 2>/dev/null)"
  [[ -z "$gitsha" ]] || ver="$ver ($gitsha)"
  say "antidote version $ver"
}

antidote2() {
  ##? antidote - the cure to slow zsh plugin management
  ##?
  ##? Usage: antidote [<flags>] <command> [<args> ...]
  ##?
  ##? Flags:
  ##?   -h, --help             Show context-sensitive help.
  ##?   -v, --version          Show application version.
  ##?
  ##? Commands:
  ##?   help <command>         Show documentation.
  ##?   bundle [<bundles>...]  Clone bundle(s) and generate Zsh source.
  ##?   update                 Update cloned bundles.
  ##?   home                   Print where antidote is cloning bundles.
  ##?   purge <bundle>         Remove a cloned bundle.
  ##?   list                   List cloned bundles.
  ##?   path <bundle>          Print the path of a cloned bundle.
  ##?   init                   Initialize the shell for dynamic bundles.

  local o_help o_version o_debug
  zparseopts ${ANTIDOTE_ZPARSEOPTS} -- \
    d=o_debug   -debug=d   \
    h=o_help    -help=h    \
    v=o_version -version=v ||
    return 1

  if (( ${#o_debug} )); then
    ANTIDOTE_DEBUG=true
    setopt WARN_CREATE_GLOBAL WARN_NESTED_VAR
  fi

  if (( ${#o_version} )); then
    antidote_version
    return 0

  elif (( ${#o_help} )); then
    antidote_help "$@"
    return 0

  elif [[ ${#} -eq 0 ]]; then
    antidote_help
    return 2
  fi

  local cmd=${1}; shift
  if [[ "$ANTIDOTE_DEBUG" == true ]] && [[ "$cmd" == run ]]; then
    cmd="$1"
    shift
    "${cmd}" "$@"
    return $?
  elif (( $+functions[antidote_${cmd}] )); then
    antidote_${cmd} "$@"
    return $?
  else
    die 2 "command not found '$cmd'."
  fi
}
antidote2 "$@"
