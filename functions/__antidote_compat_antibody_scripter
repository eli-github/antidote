#!/bin/zsh

### NOTE:
### This is a no frills implementation of antibody behavior. If antibody didn't
### support it, we don't support it here. That means a lot of antidote's new features
### are completely ignored (eg: no zcompiling, no fpath rules, no autoload plugins,
### no pre/post functions, etc, etc). I don't expect anyone to really want this, but
### it's available.

### Generate the Zsh script to load a plugin the way antibody did.
#
# usage: __antidote_compat_antibody_scripter [-k|--kind <kind>] [-p|--path <path>]
#                                 [-b|--branch <branch>] <bundle>
# <kind>   : zsh,path,fpath,clone
# <path>   : Relative path from the bundle root
# <branch> : The git branch
# <bundle> : A bundle can be a directory, a zsh script, or a git repo

### Generate the Zsh script to load a plugin.
#function __antidote_compat_antibody_scripter {
  emulate -L zsh; setopt local_options $_adote_funcopts

  local o_kind o_path o_branch
  zparseopts $_adote_zparopt_flags -- \
    k:=o_kind      -kind:=k   \
    p:=o_path      -path:=p   \
    b:=o_branch    -branch:=b ||
    return 1

  # set defaults
  (( $#o_kind )) || o_kind=(--kind zsh)

  # Check the kind value, and default to kind:zsh.
  local supported_kind_vals=(clone fpath path zsh)
  if (( $#o_kind )) && ! (( $supported_kind_vals[(Ie)$o_kind[-1]] )); then
    o_kind=(--kind zsh)
  fi

  local bundle=$1
  [[ -n "$bundle" ]] || return
  local bundle_name=$(__antidote_bundle_name $bundle)

  # replace ~/ with $HOME/
  if [[ "$bundle" == '~/'* ]]; then
    bundle=$HOME/${bundle#'~/'*}
  fi

  # set the path to the bundle (repo or local)
  local bundle_path
  [[ -e "$bundle" ]] && bundle_path=$bundle || bundle_path=$(__antidote_bundle_dir $bundle)

  # handle cloning repo bundles
  local bundle_type
  bundle_type="$(__antidote_bundle_type $bundle)"
  if [[ "$bundle_type" == (repo|url|sshurl) ]] && [[ ! -e "$bundle_path" ]]; then
    local giturl=$(__antidote_tourl $bundle)
    git clone --quiet --depth 1 --recurse-submodules --shallow-submodules $o_branch $giturl $bundle_path
    [[ $? -eq 0 ]] || return 1
  fi

  # If we only needed to clone the bundle, we're done.
  if [[ "$o_kind[-1]" == "clone" ]]; then
    return
  fi

  # Add path to bundle.
  [[ -n "$o_path[-1]" ]] && bundle_path+="/$o_path[-1]"

  # Prepare to generate the script.
  local -a script=()
  bundle_type="$(__antidote_bundle_type $bundle_path)"

  # generate load script
  local fpath_script="fpath+=( $bundle_path )"
  if [[ "$o_kind[-1]" == fpath ]]; then
    # fpath
    script+="$fpath_script"
  elif [[ "$o_kind[-1]" == path ]]; then
    # path
    script+="export PATH=\"$bundle_path:\$PATH\""
  else
    if [[ $bundle_type == file ]]; then
      script+="source $bundle_path"
    else
      # directory/default
      local initfile initfiles
      initfiles=(${(@f)$(__antidote_initfiles $bundle_path)})
      # if no init file was found, assume the default
      if [[ $#initfiles -eq 0 ]]; then
        if (( $#o_path )); then
          initfiles=($bundle_path/${bundle_path:t}.plugin.zsh)
        else
          initfiles=($bundle_path/${bundle_name:t}.plugin.zsh)
        fi
      fi
      script+="$fpath_script"
      for initfile in $initfiles; do
        script+="source $initfile"
      done
    fi
  fi

  printf "%s\n" $script
#}
